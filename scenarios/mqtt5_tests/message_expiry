# -------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
# --------------------------------------------------------------------------

import logging
import random
import threading
import os
import sys
import ssl
from paho.mqtt import client as mqtt
from paho.mqtt.properties import Properties
from paho.mqtt.packettypes import PacketTypes
import time

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
logging.getLogger("paho").setLevel(level=logging.DEBUG)
messages=[]

TOPIC = "samples/message_expiry"

class CheckApp(object):
    """
    class to check some mqtt 5 functionality
    """

    def on_connect(self, client, userdata, flags, reasonCode, properties=None):
        """
        handler for connect
        """
        print('Connected with flags ', flags)
        print('Connected reason ', reasonCode)
        print('Connected properties', properties)
        print('Connected userdata', userdata)

    def on_message(self, client, userdata, message):
        """
        handler for message receive
        """
        msg = str(message.payload.decode("utf-8"))
        messages.append(msg)
        print('RECV Topic = ', message.topic)
        print('RECV MSG =', msg)

    def on_disconnect(self, client, userdata, flags, rc, properties=None):
        """
        handler for disconnect
        """
        print('Disconnected with flags ', flags)
        print('Disconnected reason ', rc)
        print('Disconnected properties ', properties)
        print('Disconnected userdata ', userdata)

    def on_subscribe(self, client, userdata, mid, granted_qos, properties=None):
        """
        handler for subscribe
        """
        print('SUBSCRIBED')

    def on_unsubscribe(self, client, userdata, mid, properties, reasonCodes):
        """
        handler for unsubscribe
        """
        print('UNSUBSCRIBED')

    def main(self):
        """
        main
        """
        port = 1883
        hostname = "localhost"

        print("creating 2 different clients for pub and sub with clean session=False and then subscribing")
        # print("session will expire in 30 seconds")
        sub_client = mqtt.Client("subclientMe",protocol=mqtt.MQTTv5,transport="tcp",)
        pub_client = mqtt.Client("pubclientMe", protocol=mqtt.MQTTv5,transport="tcp",)
        sub_client.enable_logger(logging.getLogger("paho"))
        pub_client.enable_logger(logging.getLogger("paho"))

        sub_client.on_connect = self.on_connect
        pub_client.on_connect = self.on_connect
        sub_client.on_message = self.on_message
        sub_client.on_disconnect = self.on_disconnect
        sub_client.on_subscribe = self.on_subscribe

        # Part 1: Non-expired message

        connect_props = Properties(PacketTypes.CONNECT)
        print("Subscriber connecting expect to receive message")
        sub_client.connect(hostname,clean_start=False,properties=connect_props)
        print("Subscriber client loop start")
        sub_client.loop_start()
        print("Subscribe to topic at 1 qos")
        sub_client.subscribe(TOPIC, qos=1)

        pub_client.connect(hostname, port, properties=connect_props)
        msg_out1="Testing message expiry interval - Non-expired message"
        print("Publishing messages with message expiry")
        publish_properties = Properties(PacketTypes.PUBLISH)
        message_expiry = 20
        publish_properties.MessageExpiryInterval = message_expiry
        pub_client.publish(TOPIC, msg_out1, qos=1, properties=publish_properties)
        print("waiting 2 seconds to receive message")
        time.sleep(2)

        if len(messages)==0:
            print("Non-expired message not received: test failed")
        else:
            msg=messages.pop()
            if msg==msg_out1:
                print("Non-expired message received: test succeeded")
        print("Publishing client disconnecting")
        pub_client.disconnect()
        print("Subscribe client loop stop")
        sub_client.loop_stop()
        print("Subscribe client disconnecting")
        sub_client.disconnect()


        # Part 2 - Expired message

        connect_props = Properties(PacketTypes.CONNECT)
        print("Subscriber connecting expect to not receive message")
        sub_client.connect(hostname,clean_start=False,properties=connect_props)
        print("Subscriber client loop start")
        sub_client.loop_start()
        print("Subscribe to topic at 1 qos")
        sub_client.subscribe(TOPIC, qos=1)
        time.sleep(2)
        
        print("sub_client Disconnecting")
        sub_client.disconnect()
        sub_client.loop_stop()

        print("Pub_client Connecting and will publish while receiver disconnected")
        pub_client.connect(hostname, port, properties=connect_props)
        msg_out1="Testing message expiry interval - Expired message"
        print("Publishing messages with message expiry")
        publish_properties = Properties(PacketTypes.PUBLISH)
        message_expiry = 20
        publish_properties.MessageExpiryInterval = message_expiry
        pub_client.publish(TOPIC, msg_out1, qos=1, properties=publish_properties)
        time.sleep(21)

        print("Subscriber connecting expect to not receive message")
        sub_client.connect(hostname,clean_start=False,properties=connect_props)
        print("Subscriber client loop start")
        sub_client.loop_start()
        print("waiting 2 seconds to receive expired message")
        time.sleep(20)

        if len(messages)==0:
            print("Expired message not received: test succeeded")
        else:
            msg=messages.pop()
            if msg==msg_out1:
                print("Expired message not received: test failed")
        sub_client.loop_stop()
        sub_client.disconnect()
        pub_client.disconnect()


if __name__ == "__main__":
    CheckApp().main()